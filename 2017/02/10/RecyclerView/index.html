<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>RecyclerView总结 | 四月一号</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">RecyclerView总结</h1><a id="logo" href="/.">四月一号</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">RecyclerView总结</h1><div class="post-meta">Feb 10, 2017<span> | </span><span class="category"><a href="/categories/View/">View</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2017/02/10/RecyclerView/" href="/2017/02/10/RecyclerView/#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#分割线"><span class="toc-number">1.</span> <span class="toc-text">分割线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#添加分割线"><span class="toc-number">1.1.</span> <span class="toc-text">添加分割线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#官方实现的分割线"><span class="toc-number">1.2.</span> <span class="toc-text">官方实现的分割线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义分割线"><span class="toc-number">1.3.</span> <span class="toc-text">自定义分割线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分割线的扩展用法"><span class="toc-number">1.4.</span> <span class="toc-text">分割线的扩展用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂布局"><span class="toc-number">2.</span> <span class="toc-text">复杂布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多类型-Item"><span class="toc-number">2.1.</span> <span class="toc-text">多类型 Item</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不规则布局"><span class="toc-number">2.2.</span> <span class="toc-text">不规则布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不规则布局的拓展使用"><span class="toc-number">2.3.</span> <span class="toc-text">不规则布局的拓展使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#StaggeredGridLayoutManager"><span class="toc-number">2.3.1.</span> <span class="toc-text">StaggeredGridLayoutManager</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GridLayoutManager"><span class="toc-number">2.3.2.</span> <span class="toc-text">GridLayoutManager</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拖动排序和滑动删除"><span class="toc-number">3.</span> <span class="toc-text">拖动排序和滑动删除</span></a></li></ol></div></div><div class="post-content"><p>RecyclerView 作为 ListView 和 GridView 的<em>升级版</em>, 使用已经相当普遍. 这里总结一下相关知识点, 作为笔记.</p>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><h3 id="添加分割线"><a href="#添加分割线" class="headerlink" title="添加分割线"></a>添加分割线</h3><p>RecyclerView 本身没有支持分割线的属性, 不过可以通过下面这个方法添加.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void addItemDecoration(ItemDecoration decor) &#123;    </div><div class="line">    addItemDecoration(decor, -1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="官方实现的分割线"><a href="#官方实现的分割线" class="headerlink" title="官方实现的分割线"></a>官方实现的分割线</h3><p><em>ItemDecoration</em> 是 RecyclerView 的一个内部抽象类. 从 RecyclerView 25.0.0 开始, 出现了官方实现的分割线 <em>DividerItemDecoration</em>, 不过只支持 LinearLayoutManager.</p>
<h3 id="自定义分割线"><a href="#自定义分割线" class="headerlink" title="自定义分割线"></a>自定义分割线</h3><p>要自定义分割线, 先要理解 <em>ItemDecoration</em>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">public class ItemDivider extends RecyclerView.ItemDecoration &#123;   </div><div class="line">     // 构造方法,可以在这里做一些初始化,比如指定画笔颜色什么的</div><div class="line">     public <span class="function"><span class="title">ItemDivider</span></span>() &#123;       </div><div class="line">     &#125;    </div><div class="line"></div><div class="line">    /**     </div><div class="line">     * 指定item之间的间距(就是指定分割线的宽度)   回调顺序 1     </div><div class="line">     * @param outRect Rect to receive the output.      </div><div class="line">     * @param view    The child view to decorate     </div><div class="line">     * @param parent  RecyclerView this ItemDecoration is decorating     </div><div class="line">     * @param state   The current state of RecyclerView.     </div><div class="line">     */    </div><div class="line">     @Override    </div><div class="line">     public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123;        </div><div class="line">        super.getItemOffsets(outRect, view, parent, state);        </div><div class="line">     &#125;    </div><div class="line"></div><div class="line">    /**     </div><div class="line">     * 在item 绘制之前调用(就是绘制在 item 的底层)  回调顺序 2     </div><div class="line">     * 一般分割线在这里绘制     </div><div class="line">     * 看到canvas,对自定义控件有一定了解的话,就能想到为什么说给RecyclerView设置分割线更灵活了</div><div class="line">     * @param c      Canvas to draw into     </div><div class="line">     * @param parent RecyclerView this ItemDecoration is drawing into     </div><div class="line">     * @param state  The current state of RecyclerView     </div><div class="line">     */    </div><div class="line">     @Override    </div><div class="line">     public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;        </div><div class="line">         super.onDraw(c, parent, state);             </div><div class="line">     &#125;    </div><div class="line"></div><div class="line">    /**     </div><div class="line">     * 在item 绘制之后调用(就是绘制在 item 的上层)  回调顺序 3     </div><div class="line">     * 也可以在这里绘制分割线,和上面的方法 二选一     </div><div class="line">     * @param c      Canvas to draw into     </div><div class="line">     * @param parent RecyclerView this ItemDecoration is drawing into     </div><div class="line">     * @param state  The current state of RecyclerView     </div><div class="line">     */    </div><div class="line">     @Override   </div><div class="line">     public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;        </div><div class="line">         super.onDrawOver(c, parent, state);    </div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>getItemOffsets 指定item 之间的间距(默认为0),将来就是在这个间距内绘制分割线</li>
<li>onDraw 在绘制 item之前执行,也就是说,在这里绘制的图形可能会被item遮盖(所以需要指定item之间的间距)</li>
<li>onDrawOver 在绘制item之后执行,在这里绘制的图形,可能会遮住item(说以如果要在这里绘制分割线的话,也要找准位置)</li>
</ul>
<p>下面是一个实现了相关方法的例子 支持 LinearLayoutManager 和 GridLayoutManager</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">public class ItemDivider extends RecyclerView.ItemDecoration &#123;   </div><div class="line"></div><div class="line">      private int dividerWith = 1;</div><div class="line">      private Paint paint;</div><div class="line">      private RecyclerView.LayoutManager layoutManager;</div><div class="line"></div><div class="line">      // 构造方法,可以在这里做一些初始化,比如指定画笔颜色什么的</div><div class="line">      public <span class="function"><span class="title">ItemDivider</span></span>() &#123;  </div><div class="line">          initPaint();</div><div class="line">          paint.setColor(0xffff0000);     </div><div class="line">      &#125;   </div><div class="line"></div><div class="line">      private void <span class="function"><span class="title">initPaint</span></span>() &#123;    </div><div class="line">          <span class="keyword">if</span> (paint == null) &#123;        </div><div class="line">             paint = new Paint(Paint.ANTI_ALIAS_FLAG);        </div><div class="line">             paint.setStyle(Paint.Style.FILL);    </div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      public ItemDivider <span class="built_in">set</span>DividerWith(int dividerWith) &#123;    </div><div class="line">         this.dividerWith = dividerWith;   </div><div class="line">         <span class="built_in">return</span> this;</div><div class="line"></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      public ItemDivider <span class="built_in">set</span>DividerColor(int color) &#123;    </div><div class="line">          initPaint();    </div><div class="line">          paint.setColor(color);    </div><div class="line">          <span class="built_in">return</span> this;</div><div class="line">       &#125; </div><div class="line"></div><div class="line">      /**     </div><div class="line">       * 指定item之间的间距(就是指定分割线的宽度)   回调顺序 1     </div><div class="line">       * @param outRect Rect to receive the output.      </div><div class="line">       * @param view    The child view to decorate     </div><div class="line">       * @param parent  RecyclerView this ItemDecoration is decorating     </div><div class="line">       * @param state   The current state of RecyclerView.     </div><div class="line">       */    </div><div class="line">       @Override    </div><div class="line">       public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123;        </div><div class="line">           super.getItemOffsets(outRect, view, parent, state);    </div><div class="line">            <span class="keyword">if</span> (layoutManager == null) &#123;    </div><div class="line">               layoutManager = parent.getLayoutManager();</div><div class="line">            &#125;</div><div class="line">            // 适用 LinearLayoutManager 和 GridLayoutManager</div><div class="line">            <span class="keyword">if</span> (layoutManager instanceof LinearLayoutManager) &#123;    </div><div class="line">               int orientation = ((LinearLayoutManager) layoutManager).getOrientation();    </div><div class="line">               <span class="keyword">if</span> (orientation == LinearLayoutManager.VERTICAL) &#123;        </div><div class="line">                   // 水平分割线将绘制在item底部        </div><div class="line">                   outRect.bottom = dividerWith;    </div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orientation == LinearLayoutManager.HORIZONTAL) &#123;        </div><div class="line">                   // 垂直分割线将绘制在item右侧        </div><div class="line">                   outRect.right = dividerWith;   </div><div class="line">               &#125;    </div><div class="line">               <span class="keyword">if</span> (layoutManager instanceof GridLayoutManager) &#123;        </div><div class="line">                   GridLayoutManager.LayoutParams lp = (GridLayoutManager.LayoutParams) view.getLayoutParams();        </div><div class="line">                   // 如果是 GridLayoutManager 则需要绘制另一个方向上的分割线       </div><div class="line">                   <span class="keyword">if</span> (orientation == LinearLayoutManager.VERTICAL &amp;&amp; lp != null &amp;&amp; lp.getSpanIndex() &gt; 0) &#123;            </div><div class="line">                      // 如果列表是垂直方向,则最左边的一列略过            </div><div class="line">                      outRect.left = dividerWith;        </div><div class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orientation == LinearLayoutManager.HORIZONTAL &amp;&amp; lp != null &amp;&amp; lp.getSpanIndex() &gt; 0) &#123;            </div><div class="line">                      // 如果列表是水平方向,则最上边的一列略过            </div><div class="line">                      outRect.top = dividerWith;        </div><div class="line">                   &#125;    </div><div class="line">               &#125;</div><div class="line">           &#125;  </div><div class="line">       &#125;    </div><div class="line"></div><div class="line">      /**     </div><div class="line">       * 在item 绘制之前调用(就是绘制在 item 的底层)  回调顺序 2     </div><div class="line">       * 一般分割线在这里绘制     </div><div class="line">       * 看到canvas,对自定义控件有一定了解的话,就能想到为什么说给RecyclerView设置分割线更灵活了</div><div class="line">       * @param c      Canvas to draw into     </div><div class="line">       * @param parent RecyclerView this ItemDecoration is drawing into     </div><div class="line">       * @param state  The current state of RecyclerView     </div><div class="line">       */    </div><div class="line">       @Override    </div><div class="line">       public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;        </div><div class="line">           super.onDraw(c, parent, state);  </div><div class="line">           // 这个值是为了补偿横竖方向上分割线交叉处间隙</div><div class="line">           int offSet = (int) Math.ceil(dividerWith * 1f / 2);</div><div class="line">           <span class="keyword">for</span> (int i = 0; i &lt; parent.getChildCount(); i++) &#123;    </div><div class="line">                View child = parent.getChildAt(i);    </div><div class="line">                RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child.getLayoutParams();   </div><div class="line">                int left1 = child.getRight() + params.rightMargin;</div><div class="line">                int right1 = left1 + dividerWith;</div><div class="line">                int top1 = child.getTop() - offSet - params.topMargin;</div><div class="line">                int bottom1 = child.getBottom() + offSet + params.bottomMargin;</div><div class="line">                //绘制分割线(矩形)</div><div class="line">                c.drawRect(left1, top1, right1, bottom1, paint);</div><div class="line">                int left2 = child.getLeft() - offSet - params.leftMargin;</div><div class="line">                int right2 = child.getRight() + offSet + params.rightMargin;</div><div class="line">                int top2 = child.getBottom() + params.bottomMargin;</div><div class="line">                int bottom2 = top2 + dividerWith;</div><div class="line">                //绘制分割线(矩形)</div><div class="line">                c.drawRect(left2, top2, right2, bottom2, paint);</div><div class="line">            &#125;         </div><div class="line">       &#125;    </div><div class="line"></div><div class="line">      /**     </div><div class="line">       * 在item 绘制之后调用(就是绘制在 item 的上层)  回调顺序 3     </div><div class="line">       * 也可以在这里绘制分割线,和上面的方法 二选一     </div><div class="line">       * @param c      Canvas to draw into     </div><div class="line">       * @param parent RecyclerView this ItemDecoration is drawing into     </div><div class="line">       * @param state  The current state of RecyclerView     </div><div class="line">       */    </div><div class="line">       @Override   </div><div class="line">       public void onDrawOver(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;        </div><div class="line">         super.onDrawOver(c, parent, state);    </div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>使用方式如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">recyclerView.addItemDecoration(new ItemDivider().setDividerWith(2).setDividerColor(Color.BLUE));</div></pre></td></tr></table></figure></p>
<div align="center"><br>实际效果<br><br><br><img src="http://upload-images.jianshu.io/upload_images/1825319-d82ddfb45b551b2e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="240" height="400" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/1825319-c137a4df617f0b15.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="240" height="400" alt=""><br></div>

<h3 id="分割线的扩展用法"><a href="#分割线的扩展用法" class="headerlink" title="分割线的扩展用法"></a>分割线的扩展用法</h3><p>比如常常出现在联系人列表, 或者城市列表等页面的分栏效果, 利用 RecyclerView 的分割线, 也可以实现. 这里将其封装为一个单独的控件.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line">public class StickyRecyclerView extends RecyclerView &#123;    </div><div class="line"></div><div class="line">     private int lineHeight,titleHeight;    </div><div class="line">     private int lineColor,titleColor,titleTextColor;    </div><div class="line"></div><div class="line">     public StickyRecyclerView(Context context) &#123;        </div><div class="line">         this(context,null);    </div><div class="line">     &#125;    </div><div class="line"></div><div class="line">     public StickyRecyclerView(Context context, @Nullable AttributeSet attrs) &#123;       </div><div class="line">         this(context, attrs,0);    </div><div class="line">     &#125;   </div><div class="line"></div><div class="line">     public StickyRecyclerView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123;        </div><div class="line">          super(context, attrs, defStyle);        </div><div class="line">          TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.StickyRecyclerView);        </div><div class="line">          // 分割线的高度       </div><div class="line">          lineHeight = array.getDimensionPixelOffset(R.styleable.StickyRecyclerView_dividerHeight,1);       </div><div class="line">           // 分栏的高度       </div><div class="line">          titleHeight = array.getDimensionPixelOffset(R.styleable.StickyRecyclerView_titleHeight,dip2px(context,35));       </div><div class="line">           // 分割线颜色        </div><div class="line">          lineColor = array.getColor(R.styleable.StickyRecyclerView_dividerColor,Color.LTGRAY);            </div><div class="line">          // 分栏背景色        </div><div class="line">          titleColor = array.getColor(R.styleable.StickyRecyclerView_titleColor,Color.LTGRAY);        </div><div class="line">          // 分栏文字颜色       </div><div class="line">          titleTextColor = array.getColor(R.styleable.StickyRecyclerView_titleTextColor,Color.BLUE);        </div><div class="line">          array.recycle();        </div><div class="line">          // 不用说,肯定是线性布局了,默认就实现        </div><div class="line">          <span class="built_in">set</span>LayoutManager(new LinearLayoutManager(context));    </div><div class="line">       &#125;    </div><div class="line"></div><div class="line">       @Deprecated    </div><div class="line">       @Override    </div><div class="line">       public void <span class="built_in">set</span>Adapter(Adapter adapter) &#123;        </div><div class="line">           super.setAdapter(adapter);   </div><div class="line">       &#125;    </div><div class="line"></div><div class="line">       // 让 adapter 必须继承 StickyAdapter    </div><div class="line">       public void <span class="built_in">set</span>Adapter(@NonNull StickyAdapter stickyAdapter)&#123;        </div><div class="line">          addItemDecoration(new StickyDivider(stickyAdapter));        </div><div class="line">          super.setAdapter(stickyAdapter);    </div><div class="line">        &#125;    </div><div class="line"></div><div class="line">        /**     </div><div class="line">         * 自定义分割线,通过分割线绘制title    </div><div class="line">         */    </div><div class="line">         private class StickyDivider extends ItemDecoration&#123;        </div><div class="line">         private StickyAdapter adapter;        </div><div class="line">         private Paint paint;        </div><div class="line"></div><div class="line">         StickyDivider(@NonNull StickyAdapter adapter) &#123;            </div><div class="line">              super();            </div><div class="line">              this.adapter = adapter;            </div><div class="line">              paint = new Paint(Paint.ANTI_ALIAS_FLAG);            </div><div class="line">              paint.setStyle(Paint.Style.FILL);            </div><div class="line">              paint.setTextSize(titleHeight * 0.5f);        </div><div class="line">         &#125;        </div><div class="line"></div><div class="line">         /**        </div><div class="line">          * 计算 item间间隙(是普通分割线 ,还是title)        </div><div class="line">          */        </div><div class="line">          @Override        </div><div class="line">          public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123;            </div><div class="line">               super.getItemOffsets(outRect, view, parent, state);            </div><div class="line">               <span class="keyword">if</span>(!adapter.needTitle(((LayoutParams) view.getLayoutParams()).getViewLayoutPosition()))&#123;                </div><div class="line">                    outRect.top = lineHeight;           </div><div class="line">               &#125;<span class="keyword">else</span> &#123;                </div><div class="line">                    outRect.top = titleHeight;           </div><div class="line">               &#125;        </div><div class="line">          &#125;       </div><div class="line"></div><div class="line">          /**         </div><div class="line">           * 底层绘制,绘制分栏title        </div><div class="line">           */        </div><div class="line">           @Override        </div><div class="line">           public void onDraw(Canvas c, RecyclerView parent, State state) &#123;            </div><div class="line">                 super.onDraw(c, parent, state);            </div><div class="line">                 int left = parent.getPaddingLeft();            </div><div class="line">                 int right = parent.getMeasuredWidth() - parent.getPaddingRight();            </div><div class="line">                 final int childCount = parent.getChildCount();            </div><div class="line">                 <span class="keyword">for</span> (int i = 0; i &lt; childCount; i++) &#123;                </div><div class="line">                     final View child = parent.getChildAt(i);                </div><div class="line">                     int position = ((LayoutParams) child.getLayoutParams()).getViewLayoutPosition();                </div><div class="line">                     int bottom = child.getTop() - ((LayoutParams) child.getLayoutParams()).topMargin;                </div><div class="line">                     <span class="keyword">if</span>(!adapter.needTitle(position))&#123;                    </div><div class="line">                          // 画分割线                    </div><div class="line">                          int top = bottom - lineHeight;                    </div><div class="line">                          paint.setColor(lineColor);                    </div><div class="line">                          c.drawRect(left, top, right, bottom, paint);                </div><div class="line">                     &#125;<span class="keyword">else</span> &#123;                    </div><div class="line">                           //画TITLE                    </div><div class="line">                           int top = bottom - titleHeight;                    </div><div class="line">                           paint.setColor(titleColor);                    </div><div class="line">                           c.drawRect(left, top, right, bottom, paint);                    </div><div class="line">                           drawText(c,adapter.getItemViewTitle(position),left + titleHeight * 0.25f,bottom - titleHeight * 0.25f);                </div><div class="line">                     &#125;            </div><div class="line">                 &#125;        </div><div class="line">            &#125;        </div><div class="line"></div><div class="line">            /**         </div><div class="line">             * 上层绘制,绘制顶部悬停title        </div><div class="line">             */        </div><div class="line">             @Override        </div><div class="line">             public void onDrawOver(Canvas c, RecyclerView parent, State state) &#123;            </div><div class="line">                     super.onDrawOver(c, parent, state);            </div><div class="line">                     // 悬停title            </div><div class="line">                     int left = parent.getPaddingLeft();           </div><div class="line">                     int right = parent.getMeasuredWidth() - parent.getPaddingRight();            </div><div class="line">                     int top = parent.getPaddingTop();           </div><div class="line">                     int bottom = top + titleHeight;            </div><div class="line">                     paint.setColor(titleColor);            </div><div class="line">                     c.drawRect(left,top,right,bottom,paint);           </div><div class="line">                     int pos = ((LinearLayoutManager)(parent.getLayoutManager())).findFirstVisibleItemPosition();            </div><div class="line">                     drawText(c,adapter.getItemViewTitle(pos),left + titleHeight * 0.25f,bottom - titleHeight * 0.25f);        </div><div class="line">             &#125;        </div><div class="line"></div><div class="line">             void drawText(Canvas c, String itemViewTitle, <span class="built_in">float</span> x, <span class="built_in">float</span> y)&#123;                                        </div><div class="line">                  <span class="keyword">if</span>(!TextUtils.isEmpty(itemViewTitle))&#123;                </div><div class="line">                      paint.setColor(titleTextColor);                </div><div class="line">                      //paint.getTextBounds(itemViewTitle, 0, itemViewTitle.length(), mBounds);                </div><div class="line">                      c.drawText(itemViewTitle, x,y, paint);            </div><div class="line">                   &#125;       </div><div class="line">             &#125;    </div><div class="line">         &#125; </div><div class="line"></div><div class="line">         public static abstract class StickyAdapter extends Adapter&#123;        </div><div class="line"></div><div class="line">              // 获取当前 item 的标题        </div><div class="line">              public abstract String getItemViewTitle(int position);        </div><div class="line">              // 如果标题和前面的item的标题一样,就不需要绘制        </div><div class="line">              boolean needTitle(int position)&#123;            </div><div class="line">                  <span class="built_in">return</span> position &gt; -1 &amp;&amp; (position == 0 || !getItemViewTitle(position).equals(getItemViewTitle(position - 1)));        </div><div class="line">              &#125;    </div><div class="line">         &#125;    </div><div class="line"></div><div class="line">         public int dip2px(Context context, <span class="built_in">float</span> dpValue) &#123;       </div><div class="line">              final <span class="built_in">float</span> scale = context.getResources().getDisplayMetrics().density;        </div><div class="line">              <span class="built_in">return</span> (int) (dpValue * scale + 0.5f);    </div><div class="line">         &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>大致流程就是通过底层分割线绘制各个分栏,通过顶层分割线绘制顶部悬停的那一栏,其中,分栏背景色,高度,文字颜色,以及分割线颜色和高度都支持自定义属性控制.具体可以看下注释.</p>
<p>使用方式和普通RecyclerView 差不多:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">stickyRecyclerView.setAdapter(myAdapter);</div><div class="line"></div><div class="line">//关键一:继承关系</div><div class="line">private class MyAdapter extends StickyRecyclerView.StickyAdapter &#123;</div><div class="line">    .....</div><div class="line"></div><div class="line">   //关键二:重写该方法,返回当前item的标题</div><div class="line">  @Override</div><div class="line">  public String getItemViewTitle(int position) &#123;    </div><div class="line">     <span class="built_in">return</span> String.valueOf(datas.get(position).shuruma.charAt(0));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/1825319-147e0b6f4e3b7672.gif?imageMogr2/auto-orient/strip" width="240" height="400" alt=""><br></div>

<h2 id="复杂布局"><a href="#复杂布局" class="headerlink" title="复杂布局"></a>复杂布局</h2><h3 id="多类型-Item"><a href="#多类型-Item" class="headerlink" title="多类型 Item"></a>多类型 Item</h3><p>多类型 Item 的实现比较简单</p>
<h3 id="不规则布局"><a href="#不规则布局" class="headerlink" title="不规则布局"></a>不规则布局</h3><p>不规则布局比较常见, 比如这样:</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/1825319-ae9c6bfa7ecd13b8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="240" height="400" alt=""><br></div>

<p>或者这样:</p>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/1825319-2197a79fff897216.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="240" height="400" alt=""><br></div>

<p>使用 RecyclerView, 可以通过 <em>GridLayoutManager</em> 的一个方法实现类似上面这样的需求:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void <span class="built_in">set</span>SpanSizeLookup(SpanSizeLookup spanSizeLookup) &#123;</div><div class="line">    mSpanSizeLookup = spanSizeLookup;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>举个例子,要实现上面的第二种效果, 代码如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">gridLayoutManager.setSpanSizeLookup(new GridLayoutManager.<span class="function"><span class="title">SpanSizeLookup</span></span>() &#123;    </div><div class="line">    @Override    </div><div class="line">    public int getSpanSize(int position) &#123;  </div><div class="line">        //这里只是一个例子,实际中要根据需求来设置  </div><div class="line">        <span class="keyword">if</span>(position % 5 == 0)&#123;    </div><div class="line">            <span class="built_in">return</span> 4;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(position % 5 == 1)&#123;    </div><div class="line">            <span class="built_in">return</span> 3;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(position % 5 == 2)&#123;    </div><div class="line">            <span class="built_in">return</span> 1;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;    </div><div class="line">            <span class="built_in">return</span> 2;</div><div class="line">        &#125;     </div><div class="line">    &#125;    </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="不规则布局的拓展使用"><a href="#不规则布局的拓展使用" class="headerlink" title="不规则布局的拓展使用"></a>不规则布局的拓展使用</h3><p>Google官方以及一些第三方的下拉刷新控件都不支持<strong>分页功能</strong>, 因为分页功能应该让列表自己去实现. 针对简单的列表布局, 实现起来很简单, 但是对于网格布局, 就需要使用到不规则布局.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div></pre></td><td class="code"><pre><div class="line">public class SuperRefreshLayout extends SwipeRefreshLayout &#123;    </div><div class="line"></div><div class="line">        private static OnRefreshHandler onRefreshHandler;    </div><div class="line">        private static boolean isRefresh = <span class="literal">false</span>;    </div><div class="line">        private Adapter adapter;    </div><div class="line">        private int mTouchSlop;    </div><div class="line">        private <span class="built_in">float</span> mPrevX;   </div><div class="line"></div><div class="line">        public SuperRefreshLayout(Context context) &#123;        </div><div class="line">            this(context, null);    </div><div class="line">        &#125;    </div><div class="line"></div><div class="line">        public SuperRefreshLayout(Context context, AttributeSet attrs) &#123;        </div><div class="line">            super(context, attrs);        </div><div class="line">            <span class="built_in">set</span>ColorSchemeColors(0xff3b93eb);        </div><div class="line">            <span class="built_in">set</span>ProgressBackgroundColorSchemeColor(0xffffffff);        </div><div class="line">            <span class="built_in">float</span> scale = context.getResources().getDisplayMetrics().density;        </div><div class="line">            <span class="built_in">set</span>ProgressViewEndTarget(<span class="literal">true</span>, (int) (64 * scale + 0.5f));        </div><div class="line">            //refreshLayout.setProgressViewOffset(<span class="literal">false</span>,dip2px(this,-40),dip2px(this,64));        </div><div class="line">            mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();   </div><div class="line">        &#125;   </div><div class="line"></div><div class="line">       /**     </div><div class="line">        * 监听器    </div><div class="line">        */    </div><div class="line">        public void <span class="built_in">set</span>OnRefreshHandler(OnRefreshHandler handler) &#123;        </div><div class="line">           onRefreshHandler = handler;        </div><div class="line">           super.setOnRefreshListener(new OnRefreshCallBack());    </div><div class="line">        &#125;    </div><div class="line"></div><div class="line">       /**     </div><div class="line">        * 自动刷新,原生不支持,通过反射修改字段属性     </div><div class="line">        */    </div><div class="line">        public void <span class="function"><span class="title">autoRefresh</span></span>() &#123;        </div><div class="line">            try &#123;            </div><div class="line">                <span class="built_in">set</span>Refreshing(<span class="literal">true</span>);            </div><div class="line">                Field field = SwipeRefreshLayout.class.getDeclaredField(<span class="string">"mNotify"</span>);            </div><div class="line">                field.setAccessible(<span class="literal">true</span>);            </div><div class="line">                field.set(this, <span class="literal">true</span>);        </div><div class="line">            &#125; catch (Exception e) &#123;            </div><div class="line">                <span class="keyword">if</span>(onRefreshHandler != null)&#123;                </div><div class="line">                    onRefreshHandler.refresh();            </div><div class="line">                &#125;        </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line"></div><div class="line">        @Override    </div><div class="line">        public void <span class="built_in">set</span>Refreshing(boolean refreshing) &#123;        </div><div class="line">            super.setRefreshing(refreshing);        </div><div class="line">            isRefresh = isRefreshing();    </div><div class="line">        &#125;    </div><div class="line">     </div><div class="line">       /**     </div><div class="line">        * 加载完毕     </div><div class="line">        * @param hasMore 是否还有下一页     </div><div class="line">        */    </div><div class="line">        public void loadComplete(boolean hasMore)&#123;        </div><div class="line">            <span class="keyword">if</span>(adapter == null)&#123;            </div><div class="line">                throw new RuntimeException(<span class="string">"must call method setAdapter to bind data"</span>);        </div><div class="line">            &#125;        </div><div class="line">            adapter.setState(hasMore ? Adapter.STATE_MORE : Adapter.STATE_END);    </div><div class="line">        &#125;    </div><div class="line"></div><div class="line">       /**     </div><div class="line">        * 加载出错     </div><div class="line">        */    </div><div class="line">        public void <span class="function"><span class="title">loadError</span></span>()&#123;        </div><div class="line">            <span class="keyword">if</span>(adapter == null)&#123;            </div><div class="line">                throw new RuntimeException(<span class="string">"must call method setAdapter to bind data"</span>);       </div><div class="line">            &#125;        </div><div class="line">            adapter.setState(Adapter.STATE_ERROR);    </div><div class="line">        &#125;    </div><div class="line"></div><div class="line">       /**    </div><div class="line">        * 只支持 RecyclerView 加载更多,且需要通过此方法设置适配器     </div><div class="line">        */    </div><div class="line">        public void <span class="built_in">set</span>Adapter(@NonNull RecyclerView recyclerView,</div><div class="line">                                                 @NonNull SuperRefreshLayout.Adapter mAdapter) &#123;        </div><div class="line">            adapter = mAdapter;        </div><div class="line">            recyclerView.setAdapter(adapter);        </div><div class="line">            recyclerView.addOnScrollListener(new RecyclerView.<span class="function"><span class="title">OnScrollListener</span></span>() &#123;            </div><div class="line">                @Override            </div><div class="line">                public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123;                </div><div class="line">                    super.onScrollStateChanged(recyclerView, newState);                </div><div class="line">                    <span class="keyword">if</span> (onRefreshHandler != null </div><div class="line">                            &amp;&amp; !isRefreshing()                        </div><div class="line">                            &amp;&amp; (adapter.getState() == Adapter.STATE_MORE </div><div class="line">                                || adapter.getState() == Adapter.STATE_ERROR)                        </div><div class="line">                            &amp;&amp; newState == RecyclerView.SCROLL_STATE_IDLE                        </div><div class="line">                            &amp;&amp; !ViewCompat.canScrollVertically(recyclerView, 1)                        </div><div class="line">                            ) &#123;                    </div><div class="line">                        adapter.setState(Adapter.STATE_LOAIND);                    </div><div class="line">                        onRefreshHandler.loadMore();                </div><div class="line">                    &#125;           </div><div class="line">                &#125;       </div><div class="line">            &#125;);    </div><div class="line">        &#125;    </div><div class="line"></div><div class="line">       /**     </div><div class="line">        * 如果滑动控件嵌套过深,可通过该方法控制是否可以下拉     </div><div class="line">        */    </div><div class="line">        public void <span class="built_in">set</span>RefreshEnable(boolean <span class="built_in">enable</span>)&#123;       </div><div class="line">            // boolean e = !ViewCompat.canScrollVertically(scrollView,-1);        </div><div class="line">            <span class="keyword">if</span>(isEnabled() &amp;&amp; !<span class="built_in">enable</span>)&#123;            </div><div class="line">                <span class="built_in">set</span>Enabled(<span class="literal">false</span>);        </div><div class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!isEnabled() &amp;&amp; <span class="built_in">enable</span>)&#123;            </div><div class="line">                <span class="built_in">set</span>Enabled(<span class="literal">true</span>);        </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line"></div><div class="line">       /**     </div><div class="line">        * 解决水平滑动冲突     </div><div class="line">        */</div><div class="line">        @Override    </div><div class="line">        public boolean onInterceptTouchEvent(MotionEvent event) &#123;        </div><div class="line">            switch (event.getAction()) &#123;            </div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:               </div><div class="line">                mPrevX = MotionEvent.obtain(event).getX();                </div><div class="line">                <span class="built_in">break</span>;            </div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:                </div><div class="line">                final <span class="built_in">float</span> eventX = event.getX();                </div><div class="line">                <span class="built_in">float</span> xDiff = Math.abs(eventX - mPrevX);               </div><div class="line">                <span class="keyword">if</span> (xDiff &gt; mTouchSlop) &#123;                   </div><div class="line">                    <span class="built_in">return</span> <span class="literal">false</span>;               </div><div class="line">                &#125;        </div><div class="line">            &#125;        </div><div class="line">            <span class="built_in">return</span> super.onInterceptTouchEvent(event);   </div><div class="line">        &#125;    </div><div class="line"></div><div class="line">        private class OnRefreshCallBack implements OnRefreshListener &#123;        </div><div class="line">            @Override        </div><div class="line">            public void <span class="function"><span class="title">onRefresh</span></span>() &#123;            </div><div class="line">                <span class="keyword">if</span>(adapter != null &amp;&amp; adapter.getState() != Adapter.STATE_MORE)&#123;                 </div><div class="line">                    adapter.setState(Adapter.STATE_MORE);            </div><div class="line">                &#125;            </div><div class="line">                <span class="keyword">if</span>(onRefreshHandler != null)&#123;                </div><div class="line">                    onRefreshHandler.refresh();            </div><div class="line">                &#125;        </div><div class="line">            &#125;    </div><div class="line">        &#125;   </div><div class="line"></div><div class="line">        public static abstract class OnRefreshHandler&#123;        </div><div class="line">            public abstract void refresh();        </div><div class="line">            public void <span class="function"><span class="title">loadMore</span></span>() &#123;        </div><div class="line">            &#125;   </div><div class="line">        &#125;    </div><div class="line"></div><div class="line">       /**     </div><div class="line">        * 支持加载更多的适配器    </div><div class="line">        */    </div><div class="line">        public static abstract class Adapter extends RecyclerView.Adapter &#123;        </div><div class="line">            static final int STATE_MORE = 0, STATE_LOAIND = 1, STATE_END = 2, STATE_ERROR = 3;        </div><div class="line">            int state = STATE_MORE;        </div><div class="line"></div><div class="line">            public void <span class="built_in">set</span>State(int state) &#123;           </div><div class="line">                <span class="keyword">if</span> (this.state != state) &#123;                </div><div class="line">                    this.state = state;                </div><div class="line">                    notifyItemChanged(getItemCount() - 1);           </div><div class="line">                &#125;       </div><div class="line">            &#125;       </div><div class="line"></div><div class="line">            public int <span class="function"><span class="title">getState</span></span>() &#123;           </div><div class="line">                    <span class="built_in">return</span> state;       </div><div class="line">            &#125;        </div><div class="line"></div><div class="line">            @Override        </div><div class="line">            public int getItemViewType(int position) &#123;           </div><div class="line">                <span class="keyword">if</span> (position == getItemCount() - 1) &#123;                </div><div class="line">                    <span class="built_in">return</span> -99;           </div><div class="line">                &#125;            </div><div class="line">                <span class="built_in">return</span> getItemType(position);        </div><div class="line">            &#125;        </div><div class="line"></div><div class="line">            @Override        </div><div class="line">            public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;            </div><div class="line">                <span class="keyword">if</span> (viewType == -99) &#123;                </div><div class="line">                    <span class="built_in">return</span> new RecyclerView.ViewHolder(LayoutInflater.from(parent.getContext())</div><div class="line">                                  .inflate(R.layout.loadmore_default_footer, parent, <span class="literal">false</span>)) &#123;&#125;;            </div><div class="line">                &#125; <span class="keyword">else</span> &#123;               </div><div class="line">                    <span class="built_in">return</span> onCreateItemHolder(parent, viewType);            </div><div class="line">                &#125;       </div><div class="line">            &#125;        </div><div class="line"></div><div class="line">            @Override        </div><div class="line">            public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) &#123;            </div><div class="line">                <span class="keyword">if</span> (getItemViewType(position) == -99) &#123;                </div><div class="line">                    ProgressBar progressBar = (ProgressBar) holder.itemView</div><div class="line">                                        .findViewById(R.id.loadmore_default_footer_progressbar);                </div><div class="line">                    TextView textView = (TextView) holder.itemView</div><div class="line">                                                 .findViewById(R.id.loadmore_default_footer_tv);                </div><div class="line">                    <span class="keyword">if</span> (state == STATE_END) &#123;                    </div><div class="line">                        progressBar.setVisibility(View.GONE);                    </div><div class="line">                        textView.setText(<span class="string">"没有更多了"</span>);                </div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == STATE_MORE) &#123;                    </div><div class="line">                        progressBar.setVisibility(View.GONE);                    </div><div class="line">                        textView.setText(<span class="string">"点击加载"</span>);                </div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == STATE_LOAIND) &#123;                    </div><div class="line">                        progressBar.setVisibility(View.VISIBLE);                    </div><div class="line">                        textView.setText(<span class="string">"加载中..."</span>);               </div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == STATE_ERROR) &#123;                    </div><div class="line">                        progressBar.setVisibility(View.GONE);                    </div><div class="line">                        textView.setText(<span class="string">"加载失败,点击重新加载"</span>);                </div><div class="line">                    &#125;                </div><div class="line">                    holder.itemView.setOnClickListener(new <span class="function"><span class="title">OnClickListener</span></span>() &#123;                    </div><div class="line">                        @Override                    </div><div class="line">                        public void onClick(View view) &#123;                       </div><div class="line">                            <span class="keyword">if</span> (onRefreshHandler != null &amp;&amp; !isRefresh </div><div class="line">                                            &amp;&amp; (state == STATE_MORE || state == STATE_ERROR)) &#123;                            </div><div class="line">                                <span class="built_in">set</span>State(STATE_LOAIND);                            </div><div class="line">                                onRefreshHandler.loadMore();                        </div><div class="line">                            &#125;                    </div><div class="line">                        &#125;                </div><div class="line">                    &#125;);            </div><div class="line">                &#125; <span class="keyword">else</span> &#123;                </div><div class="line">                    onBindItemHolder(holder,position);            </div><div class="line">                &#125;        </div><div class="line">            &#125;        </div><div class="line"></div><div class="line">            @Override        </div><div class="line">            public int <span class="function"><span class="title">getItemCount</span></span>() &#123;            </div><div class="line">                    <span class="built_in">return</span> getCount() == 0 ? 0 : getCount() + 1;        </div><div class="line">            &#125;        </div><div class="line"></div><div class="line">            public int getItemType(int position)&#123;           </div><div class="line">                <span class="built_in">return</span> super.getItemViewType(position);       </div><div class="line">            &#125;        </div><div class="line"></div><div class="line">            public abstract RecyclerView.ViewHolder onCreateItemHolder(ViewGroup parent, </div><div class="line">                                                                                  int viewType);        </div><div class="line"></div><div class="line">            public abstract void onBindItemHolder(RecyclerView.ViewHolder holder, int position);        </div><div class="line"></div><div class="line">            public abstract int getCount();        </div><div class="line"></div><div class="line">            @Override        </div><div class="line">            public void onViewAttachedToWindow(RecyclerView.ViewHolder holder) &#123;            </div><div class="line">                // 处理瀑布流模式 最后的 item 占整行            </div><div class="line">                <span class="keyword">if</span> (holder.getLayoutPosition() == getItemCount() - 1) &#123;                </div><div class="line">                    LayoutParams lp = holder.itemView.getLayoutParams();                                      </div><div class="line">                    <span class="keyword">if</span> (lp != null &amp;&amp; lp instanceof StaggeredGridLayoutManager.LayoutParams) &#123;                    </div><div class="line">                        StaggeredGridLayoutManager.LayoutParams p = </div><div class="line">                                                (StaggeredGridLayoutManager.LayoutParams) lp;                    </div><div class="line">                        p.setFullSpan(<span class="literal">true</span>);               </div><div class="line">                    &#125;            </div><div class="line">                &#125;        </div><div class="line">            &#125;        </div><div class="line"></div><div class="line">            @Override        </div><div class="line">            public void onAttachedToRecyclerView(RecyclerView recyclerView) &#123;            </div><div class="line">                // 处理网格布局模式 最后的 item 占整行            </div><div class="line">                final RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();           </div><div class="line">                <span class="keyword">if</span> (layoutManager instanceof GridLayoutManager) &#123;                </div><div class="line">                    GridLayoutManager gridManager = ((GridLayoutManager) layoutManager);                </div><div class="line">                    final GridLayoutManager.SpanSizeLookup spanSizeLookup = </div><div class="line">                                                                 gridManager.getSpanSizeLookup();               </div><div class="line">                    final int lastSpanCount = gridManager.getSpanCount();                </div><div class="line">                    gridManager.setSpanSizeLookup(new GridLayoutManager.<span class="function"><span class="title">SpanSizeLookup</span></span>() &#123;                    </div><div class="line">                        @Override                    </div><div class="line">                        public int getSpanSize(int position) &#123;                        </div><div class="line">                            <span class="built_in">return</span> position == getItemCount() - 1 ? </div><div class="line">                                                    lastSpanCount : (spanSizeLookup == null ? </div><div class="line">                                                       1 : spanSizeLookup.getSpanSize(position));                   </div><div class="line">                        &#125;                </div><div class="line">                    &#125;);            </div><div class="line">                &#125;       </div><div class="line">            &#125;   </div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中, 去掉和 下拉刷新相关的代码, <strong>整体思路就是给RecyclerView在末尾添加了一个item,并且必要保证这个item占据整行.</strong> 所以需要处理两种情况:</p>
<h4 id="StaggeredGridLayoutManager"><a href="#StaggeredGridLayoutManager" class="headerlink" title="StaggeredGridLayoutManager"></a>StaggeredGridLayoutManager</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) lp; </div><div class="line">//设置为占满整行</div><div class="line">p.setFullSpan(<span class="literal">true</span>);</div></pre></td></tr></table></figure>
<h4 id="GridLayoutManager"><a href="#GridLayoutManager" class="headerlink" title="GridLayoutManager"></a>GridLayoutManager</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">gridManager.setSpanSizeLookup(new GridLayoutManager.<span class="function"><span class="title">SpanSizeLookup</span></span>() &#123; </div><div class="line">        @Override </div><div class="line">        public int getSpanSize(int position) &#123; </div><div class="line">            <span class="built_in">return</span> position == getItemCount() - 1 ? lastSpanCount : </div><div class="line">                (spanSizeLookup == null ? 1 : spanSizeLookup.getSpanSize(position)); </div><div class="line">        &#125; </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/1825319-8d48eb8ee2cdc86f.gif?imageMogr2/auto-orient/strip" width="240" height="400" alt=""><br></div>

<h2 id="拖动排序和滑动删除"><a href="#拖动排序和滑动删除" class="headerlink" title="拖动排序和滑动删除"></a>拖动排序和滑动删除</h2><p>RecyclerView 的拖动排序和滑动删除需要靠 ItemTouchHelper 这个类来支持, ItemTouchHelper 有个内部抽象类 Callback ,实现这个类可以让我们定义相关规则,以及处理回调事件.直接看代码,每个方法都有注释:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div></pre></td><td class="code"><pre><div class="line">public class MyItemTouchHandler extends ItemTouchHelper.Callback &#123;    </div><div class="line">          ItemTouchAdapterImpl adapter;    </div><div class="line"></div><div class="line">          public MyItemTouchHandler(@NonNull ItemTouchAdapterImpl adapter) &#123;        </div><div class="line">              this.adapter = adapter;    </div><div class="line">          &#125;    </div><div class="line"></div><div class="line">         /**     </div><div class="line">          * 设置 允许拖拽和滑动删除的方向     </div><div class="line">          */    </div><div class="line">          @Override    </div><div class="line">          public int getMovementFlags(RecyclerView recyclerView, </div><div class="line">                                                            RecyclerView.ViewHolder viewHolder) &#123;        </div><div class="line">              // 指定可 拖拽方向 和 滑动消失的方向        </div><div class="line">              int dragFlags,swipeFlags;        </div><div class="line">              RecyclerView.LayoutManager manager = recyclerView.getLayoutManager();        </div><div class="line">              <span class="keyword">if</span> (manager instanceof GridLayoutManager </div><div class="line">                                              || manager instanceof StaggeredGridLayoutManager) &#123;           </div><div class="line">                   // 上下左右都可以拖动            </div><div class="line">                   dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN </div><div class="line">                                    | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;       </div><div class="line">               &#125; <span class="keyword">else</span> &#123;            </div><div class="line">                  // 可以上下拖动            </div><div class="line">                  dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;        </div><div class="line">               &#125;        </div><div class="line">               // 可以左右方向滑动消失        </div><div class="line">               swipeFlags = ItemTouchHelper.START | ItemTouchHelper.END;        </div><div class="line">               // 如果某个值传 0 , 表示不支持该功能        </div><div class="line">               <span class="built_in">return</span> makeMovementFlags(dragFlags, swipeFlags);    </div><div class="line">          &#125;    </div><div class="line"></div><div class="line">         /**     </div><div class="line">          * 拖拽后回调,一般通过接口暴露给adapter, 让adapter去处理数据的交换     </div><div class="line">          */    </div><div class="line">          @Override    </div><div class="line">          public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder,</div><div class="line">                                                               RecyclerView.ViewHolder target) &#123;        </div><div class="line">            // 相同 viewType 之间才能拖动交换        </div><div class="line">            <span class="keyword">if</span> (viewHolder.getItemViewType() == target.getItemViewType()) &#123;            </div><div class="line">                int fromPosition = viewHolder.getAdapterPosition();</div><div class="line">                int toPosition = target.getAdapterPosition();</div><div class="line">                <span class="keyword">if</span> (fromPosition &lt; toPosition) &#123;    </div><div class="line">                //途中所有的item位置都要移动    </div><div class="line">                <span class="keyword">for</span> (int i = fromPosition; i &lt; toPosition; i++) &#123;        </div><div class="line">                    adapter.onItemMove(i, i + 1);    </div><div class="line">                &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;    </div><div class="line">                <span class="keyword">for</span> (int i = fromPosition; i &gt; toPosition; i--) &#123;        </div><div class="line">                    adapter.onItemMove(i, i - 1);    </div><div class="line">                &#125;</div><div class="line">                &#125;</div><div class="line">                adapter.notifyItemMoved(fromPosition, toPosition);</div><div class="line">                <span class="built_in">return</span> <span class="literal">true</span>;    </div><div class="line">            &#125;        </div><div class="line">            <span class="built_in">return</span> <span class="literal">false</span>;    </div><div class="line">          &#125;    </div><div class="line"></div><div class="line">         /**     </div><div class="line">          * 滑动删除后回调,一般通过接口暴露给adapter, 让adapter去删除该条数据     </div><div class="line">          */    </div><div class="line">          @Override    </div><div class="line">          public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123;        </div><div class="line">             // 删除数据        </div><div class="line">             adapter.onItemRemove(viewHolder.getAdapterPosition());        </div><div class="line">             // adapter 刷新        </div><div class="line">             adapter.notifyItemRemoved(viewHolder.getAdapterPosition());    </div><div class="line">          &#125;    </div><div class="line"></div><div class="line">          @Override    </div><div class="line">          public void onChildDraw(Canvas c, RecyclerView recyclerView,</div><div class="line">                                  RecyclerView.ViewHolder viewHolder, <span class="built_in">float</span> dX, <span class="built_in">float</span> dY, </div><div class="line">                                                    int actionState, boolean isCurrentlyActive) &#123;        </div><div class="line">             super.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, </div><div class="line">                                                                            isCurrentlyActive);       </div><div class="line">             <span class="keyword">if</span>(actionState == ItemTouchHelper.ACTION_STATE_SWIPE) &#123;            </div><div class="line">                //滑动时改变Item的透明度           </div><div class="line">                final <span class="built_in">float</span> alpha = 1 - Math.abs(dX) / (<span class="built_in">float</span>)viewHolder.itemView.getWidth();            </div><div class="line">                viewHolder.itemView.setAlpha(alpha);            </div><div class="line">                viewHolder.itemView.setTranslationX(dX);       </div><div class="line">             &#125;    </div><div class="line">          &#125;   </div><div class="line"></div><div class="line">         /**     </div><div class="line">          * item被选中(长按)     </div><div class="line">          * 这里改变了 item的背景色, 也可以通过接口暴露, 让adapter去处理逻辑     </div><div class="line">          */    </div><div class="line">          @Override    </div><div class="line">          public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) &#123;        </div><div class="line">             <span class="keyword">if</span> (actionState == ItemTouchHelper.ACTION_STATE_DRAG) &#123;            </div><div class="line">                // 拖拽状态            </div><div class="line">                viewHolder.itemView.setBackgroundColor(Color.BLUE);        </div><div class="line">             &#125;<span class="keyword">else</span> <span class="keyword">if</span> (actionState == ItemTouchHelper.ACTION_STATE_SWIPE) &#123;            </div><div class="line">                // 滑动删除状态            </div><div class="line">                viewHolder.itemView.setBackgroundColor(Color.RED);       </div><div class="line">             &#125;       </div><div class="line">             super.onSelectedChanged(viewHolder, actionState);    </div><div class="line">          &#125;   </div><div class="line"></div><div class="line">         /**     </div><div class="line">          * item取消选中(取消长按)     </div><div class="line">          * 这里改变了 item的背景色, 也可以通过接口暴露, 让adapter去处理逻辑     </div><div class="line">          */    </div><div class="line">          @Override    </div><div class="line">          public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123;        </div><div class="line">             viewHolder.itemView.setBackgroundColor(Color.TRANSPARENT);        </div><div class="line">             super.clearView(recyclerView, viewHolder);    </div><div class="line">          &#125;    </div><div class="line"></div><div class="line">         /**     </div><div class="line">          * 是否支持长按开始拖拽,默认开启     </div><div class="line">          * 或者在长按 item 的时候,手动 调用 mItemTouchHelper.startDrag(myHolder) 开启,更加灵活     </div><div class="line">          */    </div><div class="line">          @Override    </div><div class="line">          public boolean <span class="function"><span class="title">isLongPressDragEnabled</span></span>() &#123;        </div><div class="line">             <span class="built_in">return</span> adapter.autoOpenDrag();    </div><div class="line">          &#125;    </div><div class="line"></div><div class="line">         /**     </div><div class="line">          * 是否支持滑动删除,默认开启     </div><div class="line">          * 或者在长按 item 的时候,手动 调用 mItemTouchHelper.startSwipe(myHolder) 开启,更加灵活     </div><div class="line">          */    </div><div class="line">          @Override    </div><div class="line">          public boolean <span class="function"><span class="title">isItemViewSwipeEnabled</span></span>() &#123;        </div><div class="line">             <span class="built_in">return</span> adapter.autoOpenSwipe();    </div><div class="line">          &#125;    </div><div class="line"></div><div class="line">          // 建议让 adapter 实现该接口    </div><div class="line">          public static abstract class ItemTouchAdapterImpl extends RecyclerView.Adapter&#123;        </div><div class="line">             public abstract void onItemMove(int fromPosition, int toPosition);       </div><div class="line">             public abstract void onItemRemove(int position);       </div><div class="line">             // 是否自动开启拖拽        </div><div class="line">             protected boolean <span class="function"><span class="title">autoOpenDrag</span></span>()&#123;            </div><div class="line">                <span class="built_in">return</span> <span class="literal">true</span>;       </div><div class="line">             &#125;        </div><div class="line">             // 是否自动开启滑动删除        </div><div class="line">             protected boolean <span class="function"><span class="title">autoOpenSwipe</span></span>()&#123;            </div><div class="line">                <span class="built_in">return</span> <span class="literal">true</span>;        </div><div class="line">             &#125;    </div><div class="line">          &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<p>使用方式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new ItemTouchHelper(new MyItemTouchHandler(myAdapter)).attachToRecyclerView(recyclerView);</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private class MyAdapter extends MyItemTouchHandler.ItemTouchAdapterImpl&#123;</div><div class="line">       ////////////////////////////////////////</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onItemMove(int fromPosition, int toPosition) &#123;   </div><div class="line">        // 拖动排序的回调,这里交换集合中数据的位置 </div><div class="line">        Collections.swap(str, fromPosition, toPosition);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onItemRemove(int position) &#123;</div><div class="line">        // 滑动删除的回调,这里删除指定的数据</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<div align="center"><br><img src="http://upload-images.jianshu.io/upload_images/1825319-1def0b84dbc4bb34.gif?imageMogr2/auto-orient/strip" width="240" height="400" alt="拖动排序"><br><img src="http://upload-images.jianshu.io/upload_images/1825319-7598b37d2de904ec.gif?imageMogr2/auto-orient/strip" width="240" height="400" alt="滑动删除"><br></div></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://yoursite.com/2017/02/10/RecyclerView/" data-id="ciyznoten00009wttj8j341ku" class="article-share-link">分享到</a><div class="tags"><a href="/tags/RecyclerView/">RecyclerView</a></div><div class="post-nav"><a href="/2017/02/10/hello-world/" class="next">Hello World</a></div><div data-thread-key="2017/02/10/RecyclerView/" data-title="RecyclerView总结" data-url="http://yoursite.com/2017/02/10/RecyclerView/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2017/02/10/RecyclerView/" data-title="RecyclerView总结" data-url="http://yoursite.com/2017/02/10/RecyclerView/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://yoursite.com"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/View/">View</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/RecyclerView/" style="font-size: 15px;">RecyclerView</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/02/10/RecyclerView/">RecyclerView总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/10/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/" title="GitHub" target="_blank">GitHub</a><ul></ul><a href="https://gold.xitu.io/" title="掘金" target="_blank">掘金</a><ul></ul><a href="http://www.jianshu.com/c/NEt52a" title="简书" target="_blank">简书</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">四月一号.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'jinloong'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?0f4175d32d2fa29e1f8169e7ac6f28e8";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>